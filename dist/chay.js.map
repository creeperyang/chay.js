{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/browserify/node_modules/events/events.js","node_modules/jsep/build/jsep.js","node_modules/observed/lib/change.js","node_modules/observed/lib/observed.js","node_modules/observed/node_modules/debug/debug.js","src/compile.js","src/directive.js","src/directive/attr.js","src/directive/class.js","src/directive/directive.js","src/directive/event.js","src/directive/model.js","src/directive/repeat.js","src/directive/text.js","src/index.js","src/parse/expr.js","src/parse/parse-pair.js","src/parse/parseText.js","src/view-model.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"chay.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","//     JavaScript Expression Parser (JSEP) 0.3.0\n//     JSEP may be freely distributed under the MIT License\n//     http://jsep.from.so/\n\n/*global module: true, exports: true, console: true */\n(function (root) {\n\t'use strict';\n\t// Node Types\n\t// ----------\n\t\n\t// This is the full set of types that any JSEP node can be.\n\t// Store them here to save space when minified\n\tvar COMPOUND = 'Compound',\n\t\tIDENTIFIER = 'Identifier',\n\t\tMEMBER_EXP = 'MemberExpression',\n\t\tLITERAL = 'Literal',\n\t\tTHIS_EXP = 'ThisExpression',\n\t\tCALL_EXP = 'CallExpression',\n\t\tUNARY_EXP = 'UnaryExpression',\n\t\tBINARY_EXP = 'BinaryExpression',\n\t\tLOGICAL_EXP = 'LogicalExpression',\n\t\tCONDITIONAL_EXP = 'ConditionalExpression',\n\t\tARRAY_EXP = 'ArrayExpression',\n\n\t\tPERIOD_CODE = 46, // '.'\n\t\tCOMMA_CODE  = 44, // ','\n\t\tSQUOTE_CODE = 39, // single quote\n\t\tDQUOTE_CODE = 34, // double quotes\n\t\tOPAREN_CODE = 40, // (\n\t\tCPAREN_CODE = 41, // )\n\t\tOBRACK_CODE = 91, // [\n\t\tCBRACK_CODE = 93, // ]\n\t\tQUMARK_CODE = 63, // ?\n\t\tSEMCOL_CODE = 59, // ;\n\t\tCOLON_CODE  = 58, // :\n\n\t\tthrowError = function(message, index) {\n\t\t\tvar error = new Error(message + ' at character ' + index);\n\t\t\terror.index = index;\n\t\t\terror.description = message;\n\t\t\tthrow error;\n\t\t},\n\n\t// Operations\n\t// ----------\n\t\n\t// Set `t` to `true` to save space (when minified, not gzipped)\n\t\tt = true,\n\t// Use a quickly-accessible map to store all of the unary operators\n\t// Values are set to `true` (it really doesn't matter)\n\t\tunary_ops = {'-': t, '!': t, '~': t, '+': t},\n\t// Also use a map for the binary operations but set their values to their\n\t// binary precedence for quick reference:\n\t// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\n\t\tbinary_ops = {\n\t\t\t'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,\n\t\t\t'==': 6, '!=': 6, '===': 6, '!==': 6,\n\t\t\t'<': 7,  '>': 7,  '<=': 7,  '>=': 7, \n\t\t\t'<<':8,  '>>': 8, '>>>': 8,\n\t\t\t'+': 9, '-': 9,\n\t\t\t'*': 10, '/': 10, '%': 10\n\t\t},\n\t// Get return the longest key length of any object\n\t\tgetMaxKeyLen = function(obj) {\n\t\t\tvar max_len = 0, len;\n\t\t\tfor(var key in obj) {\n\t\t\t\tif((len = key.length) > max_len && obj.hasOwnProperty(key)) {\n\t\t\t\t\tmax_len = len;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn max_len;\n\t\t},\n\t\tmax_unop_len = getMaxKeyLen(unary_ops),\n\t\tmax_binop_len = getMaxKeyLen(binary_ops),\n\t// Literals\n\t// ----------\n\t// Store the values to return for the various literals we may encounter\n\t\tliterals = {\n\t\t\t'true': true,\n\t\t\t'false': false,\n\t\t\t'null': null\n\t\t},\n\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\n\t\tthis_str = 'this',\n\t// Returns the precedence of a binary operator or `0` if it isn't a binary operator\n\t\tbinaryPrecedence = function(op_val) {\n\t\t\treturn binary_ops[op_val] || 0;\n\t\t},\n\t// Utility function (gets called from multiple places)\n\t// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\n\t\tcreateBinaryExpression = function (operator, left, right) {\n\t\t\tvar type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\toperator: operator,\n\t\t\t\tleft: left,\n\t\t\t\tright: right\n\t\t\t};\n\t\t},\n\t\t// `ch` is a character code in the next three functions\n\t\tisDecimalDigit = function(ch) {\n\t\t\treturn (ch >= 48 && ch <= 57); // 0...9\n\t\t},\n\t\tisIdentifierStart = function(ch) {\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\n\t\t\t\t\t(ch >= 97 && ch <= 122); // a...z\n\t\t},\n\t\tisIdentifierPart = function(ch) {\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\n\t\t\t\t\t(ch >= 48 && ch <= 57); // 0...9\n\t\t},\n\n\t\t// Parsing\n\t\t// -------\n\t\t// `expr` is a string with the passed in expression\n\t\tjsep = function(expr) {\n\t\t\t// `index` stores the character number we are currently at while `length` is a constant\n\t\t\t// All of the gobbles below will modify `index` as we move along\n\t\t\tvar index = 0,\n\t\t\t\tcharAtFunc = expr.charAt,\n\t\t\t\tcharCodeAtFunc = expr.charCodeAt,\n\t\t\t\texprI = function(i) { return charAtFunc.call(expr, i); },\n\t\t\t\texprICode = function(i) { return charCodeAtFunc.call(expr, i); },\n\t\t\t\tlength = expr.length,\n\n\t\t\t\t// Push `index` up to the next non-space character\n\t\t\t\tgobbleSpaces = function() {\n\t\t\t\t\tvar ch = exprICode(index);\n\t\t\t\t\t// space or tab\n\t\t\t\t\twhile(ch === 32 || ch === 9) {\n\t\t\t\t\t\tch = exprICode(++index);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// The main parsing function. Much of this code is dedicated to ternary expressions\n\t\t\t\tgobbleExpression = function() {\n\t\t\t\t\tvar test = gobbleBinaryExpression(),\n\t\t\t\t\t\tconsequent, alternate;\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tif(exprICode(index) === QUMARK_CODE) {\n\t\t\t\t\t\t// Ternary expression: test ? consequent : alternate\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tconsequent = gobbleExpression();\n\t\t\t\t\t\tif(!consequent) {\n\t\t\t\t\t\t\tthrowError('Expected expression', index);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\tif(exprICode(index) === COLON_CODE) {\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\talternate = gobbleExpression();\n\t\t\t\t\t\t\tif(!alternate) {\n\t\t\t\t\t\t\t\tthrowError('Expected expression', index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttype: CONDITIONAL_EXP,\n\t\t\t\t\t\t\t\ttest: test,\n\t\t\t\t\t\t\t\tconsequent: consequent,\n\t\t\t\t\t\t\t\talternate: alternate\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrowError('Expected :', index);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn test;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Search for the operation portion of the string (e.g. `+`, `===`)\n\t\t\t\t// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n\t\t\t\t// and move down from 3 to 2 to 1 character until a matching binary operation is found\n\t\t\t\t// then, return that binary operation\n\t\t\t\tgobbleBinaryOp = function() {\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tvar biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;\n\t\t\t\t\twhile(tc_len > 0) {\n\t\t\t\t\t\tif(binary_ops.hasOwnProperty(to_check)) {\n\t\t\t\t\t\t\tindex += tc_len;\n\t\t\t\t\t\t\treturn to_check;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\n\t\t\t\t// This function is responsible for gobbling an individual expression,\n\t\t\t\t// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n\t\t\t\tgobbleBinaryExpression = function() {\n\t\t\t\t\tvar ch_i, node, biop, prec, stack, biop_info, left, right, i;\n\n\t\t\t\t\t// First, try to get the leftmost thing\n\t\t\t\t\t// Then, check to see if there's a binary operator operating on that leftmost thing\n\t\t\t\t\tleft = gobbleToken();\n\t\t\t\t\tbiop = gobbleBinaryOp();\n\n\t\t\t\t\t// If there wasn't a binary operator, just return the leftmost node\n\t\t\t\t\tif(!biop) {\n\t\t\t\t\t\treturn left;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, we need to start a stack to properly place the binary operations in their\n\t\t\t\t\t// precedence structure\n\t\t\t\t\tbiop_info = { value: biop, prec: binaryPrecedence(biop)};\n\n\t\t\t\t\tright = gobbleToken();\n\t\t\t\t\tif(!right) {\n\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\n\t\t\t\t\t}\n\t\t\t\t\tstack = [left, biop_info, right];\n\n\t\t\t\t\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n\t\t\t\t\twhile((biop = gobbleBinaryOp())) {\n\t\t\t\t\t\tprec = binaryPrecedence(biop);\n\n\t\t\t\t\t\tif(prec === 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbiop_info = { value: biop, prec: prec };\n\n\t\t\t\t\t\t// Reduce: make a binary expression from the three topmost entries.\n\t\t\t\t\t\twhile ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n\t\t\t\t\t\t\tright = stack.pop();\n\t\t\t\t\t\t\tbiop = stack.pop().value;\n\t\t\t\t\t\t\tleft = stack.pop();\n\t\t\t\t\t\t\tnode = createBinaryExpression(biop, left, right);\n\t\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnode = gobbleToken();\n\t\t\t\t\t\tif(!node) {\n\t\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.push(biop_info, node);\n\t\t\t\t\t}\n\n\t\t\t\t\ti = stack.length - 1;\n\t\t\t\t\tnode = stack[i];\n\t\t\t\t\twhile(i > 1) {\n\t\t\t\t\t\tnode = createBinaryExpression(stack[i - 1].value, stack[i - 2], node); \n\t\t\t\t\t\ti -= 2;\n\t\t\t\t\t}\n\t\t\t\t\treturn node;\n\t\t\t\t},\n\n\t\t\t\t// An individual part of a binary expression:\n\t\t\t\t// e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n\t\t\t\tgobbleToken = function() {\n\t\t\t\t\tvar ch, to_check, tc_len;\n\t\t\t\t\t\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tch = exprICode(index);\n\n\t\t\t\t\tif(isDecimalDigit(ch) || ch === PERIOD_CODE) {\n\t\t\t\t\t\t// Char code 46 is a dot `.` which can start off a numeric literal\n\t\t\t\t\t\treturn gobbleNumericLiteral();\n\t\t\t\t\t} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n\t\t\t\t\t\t// Single or double quotes\n\t\t\t\t\t\treturn gobbleStringLiteral();\n\t\t\t\t\t} else if(isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis\n\t\t\t\t\t\t// `foo`, `bar.baz`\n\t\t\t\t\t\treturn gobbleVariable();\n\t\t\t\t\t} else if (ch === OBRACK_CODE) {\n\t\t\t\t\t\treturn gobbleArray();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto_check = expr.substr(index, max_unop_len);\n\t\t\t\t\t\ttc_len = to_check.length;\n\t\t\t\t\t\twhile(tc_len > 0) {\n\t\t\t\t\t\t\tif(unary_ops.hasOwnProperty(to_check)) {\n\t\t\t\t\t\t\t\tindex += tc_len;\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\ttype: UNARY_EXP,\n\t\t\t\t\t\t\t\t\toperator: to_check,\n\t\t\t\t\t\t\t\t\targument: gobbleToken(),\n\t\t\t\t\t\t\t\t\tprefix: true\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n\t\t\t\t// keep track of everything in the numeric literal and then calling `parseFloat` on that string\n\t\t\t\tgobbleNumericLiteral = function() {\n\t\t\t\t\tvar number = '', ch, chCode;\n\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\n\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker\n\t\t\t\t\t\tnumber += exprI(index++);\n\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\n\t\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tch = exprI(index);\n\t\t\t\t\tif(ch === 'e' || ch === 'E') { // exponent marker\n\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\tch = exprI(index);\n\t\t\t\t\t\tif(ch === '+' || ch === '-') { // exponent sign\n\t\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) { //exponent itself\n\t\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!isDecimalDigit(exprICode(index-1)) ) {\n\t\t\t\t\t\t\tthrowError('Expected exponent (' + number + exprI(index) + ')', index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\n\t\t\t\t\tchCode = exprICode(index);\n\t\t\t\t\t// Check to make sure this isn't a variable name that start with a number (123abc)\n\t\t\t\t\tif(isIdentifierStart(chCode)) {\n\t\t\t\t\t\tthrowError('Variable names cannot start with a number (' +\n\t\t\t\t\t\t\t\t\tnumber + exprI(index) + ')', index);\n\t\t\t\t\t} else if(chCode === PERIOD_CODE) {\n\t\t\t\t\t\tthrowError('Unexpected period', index);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: LITERAL,\n\t\t\t\t\t\tvalue: parseFloat(number),\n\t\t\t\t\t\traw: number\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t// Parses a string literal, staring with single or double quotes with basic support for escape codes\n\t\t\t\t// e.g. `\"hello world\"`, `'this is\\nJSEP'`\n\t\t\t\tgobbleStringLiteral = function() {\n\t\t\t\t\tvar str = '', quote = exprI(index++), closed = false, ch;\n\n\t\t\t\t\twhile(index < length) {\n\t\t\t\t\t\tch = exprI(index++);\n\t\t\t\t\t\tif(ch === quote) {\n\t\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(ch === '\\\\') {\n\t\t\t\t\t\t\t// Check for all of the common escape codes\n\t\t\t\t\t\t\tch = exprI(index++);\n\t\t\t\t\t\t\tswitch(ch) {\n\t\t\t\t\t\t\t\tcase 'n': str += '\\n'; break;\n\t\t\t\t\t\t\t\tcase 'r': str += '\\r'; break;\n\t\t\t\t\t\t\t\tcase 't': str += '\\t'; break;\n\t\t\t\t\t\t\t\tcase 'b': str += '\\b'; break;\n\t\t\t\t\t\t\t\tcase 'f': str += '\\f'; break;\n\t\t\t\t\t\t\t\tcase 'v': str += '\\x0B'; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstr += ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!closed) {\n\t\t\t\t\t\tthrowError('Unclosed quote after \"'+str+'\"', index);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: LITERAL,\n\t\t\t\t\t\tvalue: str,\n\t\t\t\t\t\traw: quote + str + quote\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\t// Gobbles only identifiers\n\t\t\t\t// e.g.: `foo`, `_value`, `$x1`\n\t\t\t\t// Also, this function checks if that identifier is a literal:\n\t\t\t\t// (e.g. `true`, `false`, `null`) or `this`\n\t\t\t\tgobbleIdentifier = function() {\n\t\t\t\t\tvar ch = exprICode(index), start = index, identifier;\n\n\t\t\t\t\tif(isIdentifierStart(ch)) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrowError('Unexpected ' + exprI(index), index);\n\t\t\t\t\t}\n\n\t\t\t\t\twhile(index < length) {\n\t\t\t\t\t\tch = exprICode(index);\n\t\t\t\t\t\tif(isIdentifierPart(ch)) {\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tidentifier = expr.slice(start, index);\n\n\t\t\t\t\tif(literals.hasOwnProperty(identifier)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: LITERAL,\n\t\t\t\t\t\t\tvalue: literals[identifier],\n\t\t\t\t\t\t\traw: identifier\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if(identifier === this_str) {\n\t\t\t\t\t\treturn { type: THIS_EXP };\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: IDENTIFIER,\n\t\t\t\t\t\t\tname: identifier\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Gobbles a list of arguments within the context of a function call\n\t\t\t\t// or array literal. This function also assumes that the opening character\n\t\t\t\t// `(` or `[` has already been gobbled, and gobbles expressions and commas\n\t\t\t\t// until the terminator character `)` or `]` is encountered.\n\t\t\t\t// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n\t\t\t\tgobbleArguments = function(termination) {\n\t\t\t\t\tvar ch_i, args = [], node;\n\t\t\t\t\twhile(index < length) {\n\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\t\tif(ch_i === termination) { // done parsing\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (ch_i === COMMA_CODE) { // between expressions\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode = gobbleExpression();\n\t\t\t\t\t\t\tif(!node || node.type === COMPOUND) {\n\t\t\t\t\t\t\t\tthrowError('Expected comma', index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn args;\n\t\t\t\t},\n\n\t\t\t\t// Gobble a non-literal variable name. This variable name may include properties\n\t\t\t\t// e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n\t\t\t\t// It also gobbles function calls:\n\t\t\t\t// e.g. `Math.acos(obj.angle)`\n\t\t\t\tgobbleVariable = function() {\n\t\t\t\t\tvar ch_i, node;\n\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\t\t\n\t\t\t\t\tif(ch_i === OPAREN_CODE) {\n\t\t\t\t\t\tnode = gobbleGroup();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode = gobbleIdentifier();\n\t\t\t\t\t}\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\twhile(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif(ch_i === PERIOD_CODE) {\n\t\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\t\tnode = {\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\n\t\t\t\t\t\t\t\tcomputed: false,\n\t\t\t\t\t\t\t\tobject: node,\n\t\t\t\t\t\t\t\tproperty: gobbleIdentifier()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if(ch_i === OBRACK_CODE) {\n\t\t\t\t\t\t\tnode = {\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\n\t\t\t\t\t\t\t\tcomputed: true,\n\t\t\t\t\t\t\t\tobject: node,\n\t\t\t\t\t\t\t\tproperty: gobbleExpression()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\t\t\tif(ch_i !== CBRACK_CODE) {\n\t\t\t\t\t\t\t\tthrowError('Unclosed [', index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else if(ch_i === OPAREN_CODE) {\n\t\t\t\t\t\t\t// A function call is being made; gobble all the arguments\n\t\t\t\t\t\t\tnode = {\n\t\t\t\t\t\t\t\ttype: CALL_EXP,\n\t\t\t\t\t\t\t\t'arguments': gobbleArguments(CPAREN_CODE),\n\t\t\t\t\t\t\t\tcallee: node\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\t}\n\t\t\t\t\treturn node;\n\t\t\t\t},\n\n\t\t\t\t// Responsible for parsing a group of things within parentheses `()`\n\t\t\t\t// This function assumes that it needs to gobble the opening parenthesis\n\t\t\t\t// and then tries to gobble everything within that parenthesis, assuming\n\t\t\t\t// that the next thing it should see is the close parenthesis. If not,\n\t\t\t\t// then the expression probably doesn't have a `)`\n\t\t\t\tgobbleGroup = function() {\n\t\t\t\t\tindex++;\n\t\t\t\t\tvar node = gobbleExpression();\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tif(exprICode(index) === CPAREN_CODE) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrowError('Unclosed (', index);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Responsible for parsing Array literals `[1, 2, 3]`\n\t\t\t\t// This function assumes that it needs to gobble the opening bracket\n\t\t\t\t// and then tries to gobble the expressions as arguments.\n\t\t\t\tgobbleArray = function() {\n\t\t\t\t\tindex++;\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: ARRAY_EXP,\n\t\t\t\t\t\telements: gobbleArguments(CBRACK_CODE)\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\tnodes = [], ch_i, node;\n\t\t\t\t\n\t\t\twhile(index < length) {\n\t\t\t\tch_i = exprICode(index);\n\n\t\t\t\t// Expressions can be separated by semicolons, commas, or just inferred without any\n\t\t\t\t// separators\n\t\t\t\tif(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {\n\t\t\t\t\tindex++; // ignore separators\n\t\t\t\t} else {\n\t\t\t\t\t// Try to gobble each expression individually\n\t\t\t\t\tif((node = gobbleExpression())) {\n\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t// If we weren't able to find a binary expression and are out of room, then\n\t\t\t\t\t// the expression passed in probably has too much\n\t\t\t\t\t} else if(index < length) {\n\t\t\t\t\t\tthrowError('Unexpected \"' + exprI(index) + '\"', index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there's only one expression just try returning the expression\n\t\t\tif(nodes.length === 1) {\n\t\t\t\treturn nodes[0];\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ttype: COMPOUND,\n\t\t\t\t\tbody: nodes\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t// To be filled in by the template\n\tjsep.version = '0.3.0';\n\tjsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };\n\n\t/**\n\t * @method jsep.addUnaryOp\n\t * @param {string} op_name The name of the unary op to add\n\t * @return jsep\n\t */\n\tjsep.addUnaryOp = function(op_name) {\n\t\tunary_ops[op_name] = t; return this;\n\t};\n\n\t/**\n\t * @method jsep.addBinaryOp\n\t * @param {string} op_name The name of the binary op to add\n\t * @param {number} precedence The precedence of the binary op (can be a float)\n\t * @return jsep\n\t */\n\tjsep.addBinaryOp = function(op_name, precedence) {\n\t\tmax_binop_len = Math.max(op_name.length, max_binop_len);\n\t\tbinary_ops[op_name] = precedence;\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeUnaryOp\n\t * @param {string} op_name The name of the unary op to remove\n\t * @return jsep\n\t */\n\tjsep.removeUnaryOp = function(op_name) {\n\t\tdelete unary_ops[op_name];\n\t\tif(op_name.length === max_unop_len) {\n\t\t\tmax_unop_len = getMaxKeyLen(unary_ops);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeBinaryOp\n\t * @param {string} op_name The name of the binary op to remove\n\t * @return jsep\n\t */\n\tjsep.removeBinaryOp = function(op_name) {\n\t\tdelete binary_ops[op_name];\n\t\tif(op_name.length === max_binop_len) {\n\t\t\tmax_binop_len = getMaxKeyLen(binary_ops);\n\t\t}\n\t\treturn this;\n\t};\n\n\t// In desktop environments, have a way to restore the old value for `jsep`\n\tif (typeof exports === 'undefined') {\n\t\tvar old_jsep = root.jsep;\n\t\t// The star of the show! It's a function!\n\t\troot.jsep = jsep;\n\t\t// And a courteous function willing to move out of the way for other similarly-named objects!\n\t\tjsep.noConflict = function() {\n\t\t\tif(root.jsep === jsep) {\n\t\t\t\troot.jsep = old_jsep;\n\t\t\t}\n\t\t\treturn jsep;\n\t\t};\n\t} else {\n\t\t// In Node.JS environments\n\t\tif (typeof module !== 'undefined' && module.exports) {\n\t\t\texports = module.exports = jsep;\n\t\t} else {\n\t\t\texports.parse = jsep;\n\t\t}\n\t}\n}(this));\n","\nmodule.exports = exports = Change;\n\n/*!\n * Change object constructor\n *\n * The `change` object passed to Object.observe callbacks\n * is immutable so we create a new one to modify.\n */\n\nfunction Change (path, change) {\n  this.path = path;\n  this.name = change.name;\n  this.type = change.type;\n  this.object = change.object;\n  this.value = change.object[change.name];\n  this.oldValue = change.oldValue;\n}\n\n","// http://wiki.ecmascript.org/doku.php?id=harmony:observe\n\nvar Change = require('./change');\nvar Emitter = require('events').EventEmitter;\nvar debug = require('debug')('observed');\n\nmodule.exports = exports = Observable;\n\n/**\n * Observable constructor.\n *\n * The passed `subject` will be observed for changes to\n * all properties, included nested objects and arrays.\n *\n * An `EventEmitter` will be returned. This emitter will\n * emit the following events:\n *\n * - new\n * - updated\n * - deleted\n * - reconfigured\n *\n * @param {Object} subject\n * @param {Observable} [parent] (internal use)\n * @param {String} [prefix] (internal use)\n * @return {EventEmitter}\n */\n\nfunction Observable (subject, parent, prefix) {\n  if ('object' != typeof subject)\n    throw new TypeError('object expected. got: ' + typeof subject);\n\n  if (!(this instanceof Observable))\n    return new Observable(subject, parent, prefix);\n\n  debug('new', subject, !!parent, prefix);\n\n  Emitter.call(this);\n  this._bind(subject, parent, prefix);\n};\n\n// add emitter capabilities\nfor (var i in Emitter.prototype) {\n  Observable.prototype[i] = Emitter.prototype[i];\n}\n\nObservable.prototype.observers = undefined;\nObservable.prototype.onchange = undefined;\nObservable.prototype.subject = undefined;\n\n/**\n * Binds this Observable to `subject`.\n *\n * @param {Object} subject\n * @param {Observable} [parent]\n * @param {String} [prefix]\n * @api private\n */\n\nObservable.prototype._bind = function (subject, parent, prefix) {\n  if (this.subject) throw new Error('already bound!');\n  if (null == subject) throw new TypeError('subject cannot be null');\n\n  debug('_bind', subject);\n\n  this.subject = subject;\n\n  if (parent) {\n    parent.observers.push(this);\n  } else {\n    this.observers = [this];\n  }\n\n  this.onchange = onchange(parent || this, prefix);\n  Object.observe(this.subject, this.onchange);\n\n  this._walk(parent || this, prefix);\n}\n\n/**\n * Walk down through the tree of our `subject`, observing\n * objects along the way.\n *\n * @param {Observable} [parent]\n * @param {String} [prefix]\n * @api private\n */\n\nObservable.prototype._walk = function (parent, prefix) {\n  debug('_walk');\n\n  var object = this.subject;\n\n  // keys?\n  Object.getOwnPropertyNames(object).forEach(function (name) {\n    var value = object[name];\n\n    if ('object' != typeof value) return;\n    if (null == value) return;\n\n    var path = prefix\n      ? prefix + '.' + name\n      : name;\n\n    new Observable(value, parent, path);\n  });\n}\n\n/**\n * Stop listening to all bound objects\n */\n\nObservable.prototype.stop = function () {\n  debug('stop');\n\n  this.observers.forEach(function (observer) {\n    Object.unobserve(observer.subject, observer.onchange);\n  });\n}\n\n/**\n * Stop listening to changes on `subject`\n *\n * @param {Object} subject\n * @api private\n */\n\nObservable.prototype._remove = function (subject) {\n  debug('_remove', subject);\n\n  this.observers = this.observers.filter(function (observer) {\n    if (subject == observer.subject) {\n      Object.unobserve(observer.subject, observer.onchange);\n      return false;\n    }\n\n    return true;\n  });\n}\n\n/*!\n * Creates an Object.observe `onchange` listener\n */\n\nfunction onchange (parent, prefix) {\n  return function (ary) {\n    debug('onchange');\n\n    ary.forEach(function (change) {\n      var object = change.object;\n      var type = change.type;\n      var name = change.name;\n      var value = object[name];\n\n      var path = prefix\n        ? prefix + '.' + name\n        : name\n\n      if ('new' == type && null != value && 'object' == typeof value) {\n        new Observable(value, parent, path);\n      } else if ('deleted' == type && 'object' == typeof change.oldValue) {\n        parent._remove(change.oldValue);\n      }\n\n      change = new Change(path, change);\n      parent.emit(type, change);\n      parent.emit(type + ' ' + path, change);\n      parent.emit('changed', change);\n    })\n  }\n}\n\n","\n/**\n * Expose `debug()` as the module.\n */\n\nmodule.exports = debug;\n\n/**\n * Create a debugger with the given `name`.\n *\n * @param {String} name\n * @return {Type}\n * @api public\n */\n\nfunction debug(name) {\n  if (!debug.enabled(name)) return function(){};\n\n  return function(fmt){\n    fmt = coerce(fmt);\n\n    var curr = new Date;\n    var ms = curr - (debug[name] || curr);\n    debug[name] = curr;\n\n    fmt = name\n      + ' '\n      + fmt\n      + ' +' + debug.humanize(ms);\n\n    // This hackery is required for IE8\n    // where `console.log` doesn't have 'apply'\n    window.console\n      && console.log\n      && Function.prototype.apply.call(console.log, console, arguments);\n  }\n}\n\n/**\n * The currently active debug mode names.\n */\n\ndebug.names = [];\ndebug.skips = [];\n\n/**\n * Enables a debug mode by name. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} name\n * @api public\n */\n\ndebug.enable = function(name) {\n  try {\n    localStorage.debug = name;\n  } catch(e){}\n\n  var split = (name || '').split(/[\\s,]+/)\n    , len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    name = split[i].replace('*', '.*?');\n    if (name[0] === '-') {\n      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));\n    }\n    else {\n      debug.names.push(new RegExp('^' + name + '$'));\n    }\n  }\n};\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\ndebug.disable = function(){\n  debug.enable('');\n};\n\n/**\n * Humanize the given `ms`.\n *\n * @param {Number} m\n * @return {String}\n * @api private\n */\n\ndebug.humanize = function(ms) {\n  var sec = 1000\n    , min = 60 * 1000\n    , hour = 60 * min;\n\n  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';\n  if (ms >= min) return (ms / min).toFixed(1) + 'm';\n  if (ms >= sec) return (ms / sec | 0) + 's';\n  return ms + 'ms';\n};\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\ndebug.enabled = function(name) {\n  for (var i = 0, len = debug.skips.length; i < len; i++) {\n    if (debug.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (var i = 0, len = debug.names.length; i < len; i++) {\n    if (debug.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Coerce `val`.\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n// persist\n\ntry {\n  if (window.localStorage) debug.enable(localStorage.debug);\n} catch(e){}\n","'use strict';\n\nvar parsePair = require('./parse/parse-pair');\nvar directive = require('./directive');\nvar createDirective = directive.create;\nvar isPairDirective = directive.isPair;\nvar hasDirective = directive.has;\nvar ViewModel = require('./view-model');\nvar parseText = require('./parse/parseText.js');\n\nvar reIncludeExpr = /\\{\\{\\s*(.+?)\\s*\\}\\}/;\n\nvar walk = function(node, callback) {\n    if (node.nodeType === 1 || node.nodeType === 3) {\n        var returnValue = callback(node);\n        if (returnValue === false) {\n            return;\n        }\n    }\n\n    if (node.nodeType === 1) {\n        var current = node.firstChild;\n        while (current) {\n            walk(current, callback);\n            current = current.nextSibling;\n        }\n    }\n};\n\n// parse text expression\nvar parseInlineText = function(line) {\n    var parsed = parseText(line);\n    if(!parsed.length) {\n        return '';\n    }\n    return parsed.filter(function(item) {\n        // exclude empty text item\n            return !!item.value;\n        }).map(function(item) {\n            return item.type === 'text' ? \n                '\"' + item.value + '\"' :\n                '(' + item.value + ')';\n        }).join(' + ');\n};\n\n// really instance directives\nvar bindDirs = function(element, dirs, context) {\n    var dir, type, pairs, pair;\n    var i, j, k, l;\n    for (i = 0, j = dirs.length; i < j; i++) {\n        dir = dirs[i];\n        type = dir.type;\n\n        if (isPairDirective(type)) {\n            pairs = parsePair(dir.value);\n            for (k = 0, l = pairs.length; k < l; k++) {\n                pair = pairs[k];\n                createDirective(dir.type, {\n                    element: element,\n                    expression: pair.value,\n                    context: context,\n                    key: pair.key,\n                    attr: dir.attr\n                });\n            }\n        } else {\n            createDirective(dir.type, {\n                element: element,\n                expression: dir.value,\n                context: context,\n                attr: dir.attr\n            });\n        }\n    }\n};\n\n// compile element with corresponding context instance\nvar compile = function(element, context) {\n    context = new ViewModel(context);\n    walk(element, function(el) {\n        var dirs = [];\n        var attributes, attrNode, attrName, attrValue;\n        var i, j;\n        var text;\n        if (el.nodeType === 1) {\n            attributes = el.attributes;\n\n            for (i = 0, j = attributes.length; i < j; i++) {\n                attrNode = attributes.item(i);\n                attrName = attrNode.nodeName;\n                attrValue = attrNode.nodeValue;\n\n                if (reIncludeExpr.test(attrValue)) {\n                    dirs.push({\n                        type: 'hy-attr',\n                        attr: attrName,\n                        value: parseInlineText(attrValue)\n                    });\n                }\n\n                if (hasDirective(attrName)) {\n                    dirs.push({\n                        type: attrName,\n                        attr: attrName,\n                        value: attrValue\n                    });\n                }\n\n                if (attrName === 'hy-repeat') {\n                    createDirective('hy-repeat', {\n                        element: el,\n                        expression: attrNode.nodeValue,\n                        context: context\n                    });\n\n                    return false;\n                }\n            }\n        } else if (el.nodeType === 3) {\n            text = el.nodeValue;\n            if (reIncludeExpr.test(text)) {\n                dirs.push({\n                    type: 'hy-text',\n                    value: parseInlineText(text)\n                });\n            }\n        }\n\n        if (dirs.length > 0) {\n            bindDirs(el, dirs, context);\n        }\n    });\n};\n\nmodule.exports = compile;\n","'use strict';\n\n// register all directives\n\nvar directiveMap = {};\n\nvar registerDirective = function(name, directive) {\n    if (name && typeof directive === 'function') {\n        directiveMap[name] = directive;\n    }\n};\n\nvar createDirective = function(name, options) {\n    if (!name) {\n        return;\n    }\n    var CreateDirective = directiveMap[name];\n    return new CreateDirective(options);\n};\n\nvar RepeatDirective = require('./directive/repeat');\nvar AttrDirective = require('./directive/attr');\nvar TextDirective = require('./directive/text');\nvar ClassDirective = require('./directive/class');\nvar EventDirective = require('./directive/event');\nvar ModelDirective = require('./directive/model');\n\nregisterDirective('hy-repeat', RepeatDirective);\nregisterDirective('hy-attr', AttrDirective);\nregisterDirective('hy-text', TextDirective);\nregisterDirective('hy-class', ClassDirective);\nregisterDirective('hy-event', EventDirective);\nregisterDirective('hy-model', ModelDirective);\n\nvar events = ['click', 'dblclick', 'mousedown', 'mouseup', 'focus', 'blur'];\nvar createSubEventDir = function(event) {\n    var eventDir = function(options) {\n        EventDirective.call(this, options);\n    };\n    eventDir.prototype = new EventDirective();\n    eventDir.prototype.isPair = false;\n    eventDir.prototype.event = event;\n    return eventDir;\n};\n\nfor (var i = 0, j = events.length; i < j; i++) {\n    var eventType = events[i];\n    registerDirective('hy-' + eventType, createSubEventDir(eventType));\n}\n\nmodule.exports = {\n    register: registerDirective,\n    create: createDirective,\n    isPair: function(type) {\n        var fn = directiveMap[type];\n        if (!fn) {\n            return false;\n        }\n        return !!fn.prototype.isPair;\n    },\n    has: function(type) {\n        return type in directiveMap;\n    }\n};\n","'use strict';\n\nvar Directive = require('./directive.js');\n\nfunction AttrDirective(options) {\n    this.attr = options && options.attr;\n    \n    Directive.call(this, options);\n}\n\nAttrDirective.prototype = new Directive();\n\nAttrDirective.prototype.update = function() {\n    if (this.attr && this.element && this.valueFn) {\n        this.element[this.attr] = this.valueFn() || '';\n    }\n};\n\nmodule.exports = AttrDirective;\n","'use strict';\n\nvar Directive = require('./directive.js');\n\nfunction ClassDirective(options) {\n    this.className = options && options.key;\n    Directive.call(this, options);\n}\n\nClassDirective.prototype = new Directive();\n\nClassDirective.prototype.isPair = true;\n\nClassDirective.prototype.update = function() {\n    var element = this.element;\n    var value;\n    if(element.nodeType !== 1 || !this.valueFn) {\n        return;\n    }\n    value = !!this.valueFn();\n    if (value) {\n        element.classList.add(this.className);\n    } else {\n        element.classList.remove(this.className);\n    }\n};\n\nmodule.exports = ClassDirective;\n","'use strict';\n\nvar expr = require('../parse/expr');\nvar compileExpr = expr.compile;\nvar getDepends = expr.getDepends;\n\nfunction Directive(options) {\n    // just return this if options is empty\n    // the sub directive always set prototype = new Directive()\n    if(!options) {\n        return this;\n    }\n\n    this.element = options.element;\n    this.expression = options.expression;\n    this.context = options.context;\n\n    this.bind();\n}\n\n// sometimes, when subclass call bind, they may apply options to custom\nDirective.prototype.bind = function(options) {\n    var directive = this;\n    if (directive.element && directive.expression && directive.context) {\n        directive.valueFn = compileExpr(directive.expression, directive.context, options);\n\n        var depends = getDepends(directive.expression);\n        var context = directive.context;\n\n        depends.forEach(function(depend) {\n            context.$watch(depend, directive);\n        });\n\n        directive.update();\n    }\n};\n\nDirective.prototype.unbind = function() {\n    var depends = getDepends(this.expression);\n    var context = this.context;\n    var directive = this;\n\n    depends.forEach(function(depend) {\n        context.$unwatch(depend, directive);\n    });\n};\n\nDirective.prototype.update = function() {\n\n};\n\nDirective.prototype.destroy = function() {\n    this.unbind();\n\n    this.element = null;\n    this.expression = null;\n    this.context = null;\n    this.valueFn = null;\n};\n\nmodule.exports = Directive;\n","'use strict';\n\nvar Directive = require('./directive');\n\nfunction EventDirective(options) {\n\n    if(options && options.key) {\n        this.event = options.key;\n    }\n\n    Directive.call(this, options);\n\n}\n\nEventDirective.prototype = new Directive();\n\nEventDirective.prototype.isPair = true;\n\nEventDirective.prototype.bind = function() {\n    var directive = this;\n    Directive.prototype.bind.call(this, {\n        isEvent: true,\n        event: this.event\n    });\n    if(this.element) {\n        // always offer $event\n        this.element.addEventListener(this.event, function($event) {\n            directive.valueFn($event);\n        }, false);\n    }\n};\n\nEventDirective.prototype.update = function() {};\n\nmodule.exports = EventDirective;\n","'use strict';\n\nvar Directive = require('./directive');\n\nvar setter = function(obj, path, newValue) {\n    if (!obj || !path) {\n        return;\n    }\n    var paths = path.split('.'),\n        target = obj;\n    for (var i = 0, j = paths.length; i < j; i++) {\n        var subPath = paths[i],\n            value = target[subPath];\n        if (i === j - 1) {\n            target[subPath] = newValue;\n        } else {\n            if (value) {\n                target = value;\n            }\n            else {\n                return;\n            }\n        }\n    }\n};\n\nfunction ModelDirective(options) {\n    Directive.call(this, options);\n}\n\nModelDirective.prototype = new Directive();\n\nModelDirective.prototype.bind = function() {\n    var directive = this;\n\n    var element = directive.element;\n\n    var listener = function() {\n        if (element.type === 'checkbox') {\n            setter(directive.context, directive.expression, element.checked);\n        } else {\n            setter(directive.context, directive.expression, element.value);\n        }\n    };\n\n    Directive.prototype.bind.call(this, arguments);\n\n    element.addEventListener('keyup', listener, false);\n    element.addEventListener('change', listener, false);\n};\n\nModelDirective.prototype.update = function() {\n    var value = this.valueFn();\n    var element = this.element;\n\n    if (element) {\n        if (element.type === 'checkbox') {\n            value = !!value;\n            if (element.checked !== value) {\n                element.checked = value;\n            }\n        } else {\n            if (element.value !== value) {\n                element.value = value;\n            }\n        }\n    }\n};\n\nmodule.exports = ModelDirective;\n","/* jshint -W030*/\n'use strict';\n\nvar Directive = require('./directive');\nvar compileExpr = require('../parse/expr').compile;\n\nvar reRepeatExpr = /^\\s*([\\d\\w]+)\\s+in\\s+(\\S+)(\\s+track\\s+by\\s+(\\S+))?\\s*$/;\n\nfunction newContext(context) {\n    if (context.$extend) {\n        return context.$extend();\n    }\n    var Empty = function() {};\n    Empty.prototype = context;\n\n    return new Empty();\n}\n\nfunction insertAfter(newChild, refElement) {\n    if (refElement) {\n        refElement.parentNode.insertBefore(newChild, refElement.nextSibling);\n    }\n}\n\nfunction RepeatDirective(options) {\n    Directive.call(this, options);\n}\n\nRepeatDirective.prototype = new Directive();\n\n// handle current data and diff with lastMap\nRepeatDirective.prototype.diff = function(current) {\n\n    var nameOfKey = this.nameOfKey;\n    var trackByFn = this.trackByFn;\n\n    // hold all subContexts\n    var currentMap = {};\n    var prevContext = null;\n    var subContext, item;\n    var i, j;\n\n    for (i = 0, j = current.length; i < j; i++) {\n        item = current[i];\n\n        subContext = newContext(this.context);\n        subContext.$index = i;\n        subContext.$prev = prevContext ? trackByFn.call(prevContext) : null;\n        subContext[nameOfKey] = item;\n\n        currentMap[trackByFn.call(subContext)] = subContext;\n\n        prevContext = subContext;\n    }\n\n    var removed = [];\n    var added = [];\n    var moved = [];\n\n    var lastMap = this.lastMap || {};\n\n    for (var lastKey in lastMap) {\n        if (lastMap.hasOwnProperty(lastKey)) {\n            var lastContext = lastMap[lastKey];\n            var currentContext = currentMap[lastKey];\n            if (!currentContext) {\n                removed.push(lastContext);\n            } else if (currentContext && lastContext &&\n                currentContext[nameOfKey] !== lastContext[nameOfKey]) { // when track by $index\n                removed.push(lastContext);\n                added.push(currentContext);\n            }\n        }\n    }\n\n    for (var currentKey in currentMap) {\n        if (currentMap.hasOwnProperty(currentKey)) {\n            var context = currentMap[currentKey];\n            var prev = context.$prev;\n            // if not exists in lastMap, treat it as newly added\n            if (!lastMap[currentKey]) {\n                added.push(context);\n\n            // if exists in lastMap but $prev changes, push to moved\n            } else if (lastMap[currentKey].$prev !== prev) {\n                moved.push(context);\n            }\n        }\n    }\n\n    this.lastMap = currentMap;\n\n    return {\n        added: added,\n        moved: moved,\n        removed: removed\n    };\n};\n\nRepeatDirective.prototype.patch = function(patch) {\n    var itemElementMap = this.itemElementMap;\n    if (!itemElementMap) {\n        itemElementMap = this.itemElementMap = {};\n    }\n\n    var childTemplate = this.childTemplate;\n    var trackByFn = this.trackByFn;\n    var commentNode = this.refNode;\n\n    var added = patch.added;\n    var removed = patch.removed;\n    var moved = patch.moved;\n\n    // remove dom item\n    removed.forEach(function(removeContext) {\n        var key = trackByFn.apply(removeContext);\n        var el = itemElementMap[key];\n        if (el) {\n            el.parentNode && el.parentNode.removeChild(el);\n        }\n        removeContext.$destroy && removeContext.$destroy();\n        delete itemElementMap[key];\n    });\n\n    // insert newly added item\n    added.forEach(function(newContext) {\n        var compile = require('../compile');\n        var element = childTemplate.cloneNode(true);\n\n        compile(element, newContext);\n\n        var prevKey = newContext.$prev;\n        var refNode;\n        // check not null or undefined\n        /* jshint -W116 */\n        if (prevKey != null) {\n        /* jshint +W116 */\n            refNode = itemElementMap[prevKey];\n        } else {\n            refNode = commentNode;\n        }\n\n        insertAfter(element, refNode);\n\n        itemElementMap[trackByFn.call(newContext)] = element;\n    });\n\n    // move exists dom item\n    moved.forEach(function(moveContext) {\n        var key = trackByFn.apply(moveContext);\n        var el = itemElementMap[key];\n        if (!el) {\n            throw new Error('Some error happen when hv-repeat#diff.');\n        }\n\n        var prevKey = moveContext.$prev;\n        var refNode;\n\n        if (prevKey) {\n            refNode = itemElementMap[prevKey];\n        } else {\n            refNode = commentNode;\n        }\n\n        insertAfter(el, refNode);\n    });\n};\n\n// update repeat doms\nRepeatDirective.prototype.update = function() {\n    var array = this.valueFn() || [];\n\n    var patches = this.diff(array);\n    this.patch(patches);\n};\n\n// parse repeat expression\n// the expression would be like: item in list\nRepeatDirective.prototype.parseRepeatExpr = function() {\n    var definition = this.expression;\n    var nameOfKey;\n    var valueExpression;\n    var trackByExpression;\n\n    var matches = reRepeatExpr.exec(definition);\n\n    if (!matches) {\n        throw 'Invalid expression of hy-repeat: ' + definition;\n    }\n\n    nameOfKey = matches[1];\n    valueExpression = matches[2];\n    trackByExpression = matches[4];\n\n    if (trackByExpression === undefined) {\n        trackByExpression = '$index';\n    }\n\n    this.nameOfKey = nameOfKey;\n    this.trackByFn = compileExpr(trackByExpression);\n    this.valueFn = compileExpr(valueExpression, this.context);\n};\n\nRepeatDirective.prototype.bind = function() {\n    this.parseRepeatExpr();\n\n    var array = this.valueFn() || [];\n    var element = this.element;\n    // init childTemplate\n    var childTemplate = element.cloneNode(true);\n    childTemplate.removeAttribute('hy-repeat');\n    this.childTemplate = childTemplate;\n\n    // add commentNode and remove element\n    var refNode = this.refNode = document.createComment('hy-repeat: ' + this.expression);\n    element.parentNode.insertBefore(refNode, element);\n    element.parentNode && element.parentNode.removeChild(element);\n\n    this.update();\n\n    Object.observe(array, function() {\n        this.update();\n    }.bind(this));\n};\n\nmodule.exports = RepeatDirective;\n","'use strict';\n\nvar Directive = require('./directive.js');\n\nfunction TextDirective(options) {\n    Directive.call(this, options);\n}\n\nTextDirective.prototype = new Directive();\n\nTextDirective.prototype.update = function() {\n    var text = this.valueFn();\n    if (text !== undefined && text !== null) {\n        text = '' + text;\n    } else {\n        text = '';\n    }\n\n    var element = this.element;\n    if (element.nodeType === 3) {\n        this.element.nodeValue = text;\n    } else if (element.nodeType === 1) {\n        this.element.innerText = text;\n    }\n};\n\nmodule.exports = TextDirective;\n","var compile = require('./compile');\n\n// exports compile\nwindow.$compile = compile;","'use strict';\n\nvar jsep = require('jsep');\n\nvar parsedCache = {};\nvar dependsCache = {};\nvar fnCache = {};\n\nvar reWhitespace = /^\\s+$/;\n\n// parse member expression like 'a.b'\nvar parseMemberExpression = function(ast, options) {\n    var path = '';\n    var currentObject = ast.object;\n    var stack = [ast.property.name];\n    var depends = options && options.depends;\n\n    while (currentObject) {\n        if (currentObject.type === 'Identifier') {\n            stack.unshift(currentObject.name);\n            path = stack.join('.');\n            break;\n        } else if (currentObject.type === 'MemberExpression') {\n            stack.unshift(currentObject.property.name);\n            currentObject = currentObject.object;\n        }\n    }\n    if (depends && depends.indexOf(path) === -1) {\n        depends.push(path);\n    }\n    return path;\n};\n// convert ast to function code\nvar astToCodeMap = {\n    'Literal': function(ast, options) {\n        // because Literal will be function's source code, specially handle string\n        // return ' +$index+ '; must be transformed to return '\\' \\'+$index+\\' \\'';\n        return typeof ast.value === 'string' ? '\"' + ast.value + '\"' : '' + ast.value;\n    },\n    'ThisExpression': function(ast, options) {\n        return 'this';\n    },\n    // '+a'\n    'UnaryExpression': function(ast, options) {\n        return ast.operator + astToCode(ast.argument, options);\n    },\n    'MemberExpression': function(ast, options) {\n        return 'this.' + parseMemberExpression(ast, options);\n    },\n    // 'a + b', add pair to preserve execute order\n    'BinaryExpression': function(ast, options) {\n        return '(' + astToCode(ast.left, options) + ast.operator + astToCode(ast.right, options) + ')';\n    },\n    // 'a > 0 ? \"yes\" : \"no\"'\n    'ConditionalExpression': function(ast, options) {\n        return '(' + astToCode(ast.test, options) + ' ? (' + astToCode(ast.consequent, options) + ') : (' + astToCode(ast.alternate, options) + '))';\n    },\n    // 'a'\n    'Identifier': function(ast, options) {\n        var depends = options.depends;\n        // so when directive is event, specially handle $event\n        // $event is not this.$event and should not push to depends\n        if(options.event && ast.name === '$event') {\n            options.toInjectEvent = true;\n            return ast.name;\n        } \n\n        if (depends && depends.indexOf(ast.name) === -1) {\n            depends.push(ast.name);\n        }\n        return 'this.' + ast.name;\n    },\n    // '[obj.]execute(parameters)'\n    'CallExpression': function(ast, options) {\n        var args = ast.arguments;\n        var callee = ast.callee;\n        var parsedValues = [];\n        if (args) {\n            args.forEach(function(arg) {\n                parsedValues.push(astToCode(arg, options));\n            });\n        }\n        if (callee.type === 'Identifier') {\n            return astToCode(callee, options) + '(' + parsedValues.join(', ') + ')';\n        }\n        return astToCode(callee.object, options) + '.' +\n            callee.property.name + '(' + parsedValues.join(', ') + ')';\n    },\n    'ArrayExpression': function(ast, options) {\n        var elements = ast.elements,\n            mappedValues = [];\n\n        elements.forEach(function(item) {\n            mappedValues.push(astToCode(item, options));\n        });\n\n        return '[' + mappedValues.join(', ') + ']';\n    }\n};\nastToCodeMap.LogicalExpression = astToCodeMap.BinaryExpression;\n\nfunction astToCode(ast, options) {\n    return astToCodeMap[ast.type](ast, options);\n}\n\n// parse expression to code string\nvar parseExpr = function(string, options) {\n\n    options = options || {};\n    var depends;\n    var result = parsedCache[string];\n\n    if (!result) {\n        var parsedTree = jsep(string);\n\n        depends = options.depends = [];\n        result = astToCode(parsedTree, options);\n\n        parsedCache[string] = result;\n        dependsCache[string] = depends;\n    }\n\n    return result;\n};\n\n// get depends via raw string\nvar getDepends = function(string) {\n    var depends = dependsCache[string];\n\n    if (!depends) {\n        parseExpr(string);\n        depends = dependsCache[string];\n    }\n\n    return depends;\n};\n\n// parse string to executable fn(valueFn)\nvar compileExpr = function(string, context, options) {\n    var converted = parseExpr(string, options);\n    // add '()' to preserve unexpected newline\n    var body = 'return (' + converted + ');';\n    var fn = fnCache[string];\n    if (!fn) {\n        /*jshint -W054 */\n        fn = (options && options.toInjectEvent) ? new Function('$event', body) : \n            new Function(body);\n        /*jshint +W054 */\n        fnCache[string] = fn;\n    }\n    if (context) {\n        return fn.bind(context);\n    }\n    return fn;\n};\n\nmodule.exports = {\n    parse: parseExpr,\n    getDepends: getDepends,\n    compile: compileExpr,\n    cache: function() {\n        return {\n            parsedCache: parsedCache,\n            dependsCache: dependsCache,\n            fnCache: fnCache\n        };\n    }\n};\n","'use strict';\n\n// parse key-value pairs string \n// '{key1: value1, key2: value2}'\n\nvar rePair = /^\\s*\\{([\\s\\S]+)\\}\\s*$/;\n\n// remove the outmost '{}'\n// '{key:value}' --> 'key:value'\nvar prepareLine = function(line) {\n    var result = rePair.exec(line);\n    return result ? result[1] : line;\n};\n\nvar parsePair = function(line) {\n\n    line = prepareLine(line);\n    if(!line) {\n        return;\n    }\n    \n    var result = [];\n    var currentPair = {};\n    var keyBeginIndex = 0;\n    var valueBeginIndex = 0;\n\n    var charCount = line.length;\n    var index = 0;\n    var level = 0;\n    var prevChar, curChar;\n    var quotationChar;\n\n    function appendPair() {\n        currentPair.literal = line.slice(keyBeginIndex, index).trim();\n\n        if (currentPair.value === undefined) {\n            currentPair.value = line.slice(valueBeginIndex, index).trim();\n        }\n\n        if (index === 0 || currentPair.value) {\n            result.push(currentPair);\n        }\n\n        currentPair = {};\n        keyBeginIndex = valueBeginIndex = index + 1;\n    }\n\n    for(; index < charCount; index++) {\n        prevChar = curChar;\n        curChar = line.charAt(index);\n\n        // when encourter quotation mark\n        if (curChar === '\"' || curChar === '\\'') {\n            // the first part of quotation\n            if (!quotationChar) {\n                quotationChar = curChar;\n                level++;\n                continue;\n            }\n            // check if to finish quotation\n            if (quotationChar && prevChar !== '\\\\' && curChar === quotationChar) {\n                quotationChar = null;\n                level--;\n                continue;\n            }\n        }\n\n        // if not inside quotation mask\n        if(!quotationChar) {\n            if (curChar === ',' && level === 0) {\n                appendPair();\n            } else if (curChar === ':' && !currentPair.key && !currentPair.value) {\n                var key = line.slice(keyBeginIndex, index).trim();\n                if (key.length > 0) {\n                    currentPair.key = key;\n                    valueBeginIndex = index + 1;\n                }\n            } else if (curChar === '(' || curChar === '[' || curChar === '{') {\n                level++;\n            } else if (curChar === ')' || curChar === ']' || curChar === '}') {\n                level--;\n            }\n        }\n    }\n\n    // ensure appendPair() call once outside of loop\n    // the only or the last 'key: value'\n    if (index === 0 || keyBeginIndex !== index) {\n        appendPair();\n    }\n\n    return result;\n};\n\nmodule.exports = parsePair;\n","'use strict';\n\nvar reExpr = /\\{\\{([\\s\\S]+?)\\}\\}|$/g; // non-greedy match\n\nvar appendText = function(result, text) {\n    if (text !== undefined) {\n        result.push({\n            type: 'text',\n            value: text\n        });\n    }\n};\n\nvar appendExpr = function(result, text) {\n    if (text) {\n        result.push({\n            type: 'expression',\n            value: text\n        });\n    }\n};\n\nvar parseText = function(line, result) {\n    result = result || [];\n    var index = 0;\n    // remove \\r \\n firstly\n    line = line.replace(/\\n/g,'').replace(/\\r/g, '');\n\n    line.replace(reExpr, function(match, expr, offset) {\n            appendText(result, line.slice(index, offset));\n            appendExpr(result, expr);\n            index = offset + match.length;\n            return match;\n        });\n\n    return result;\n};\n\nmodule.exports = parseText;\n","'use strict';\n\nvar observed = require('observed');\n\nvar ViewModel = function(model) {\n    if (!model) {\n        return;\n    }\n\n    var callbackMap = {};\n    var observer = observed(model);\n    var emptyArray = [];\n\n    // register callback to property\n    model.$watch = function(path, callback) {\n        var callbacks = callbackMap[path];\n        if (!callbacks) {\n            callbacks = callbackMap[path] = [];\n        }\n        callbacks.push(callback);\n    };\n\n    // unregister callback\n    model.$unwatch = function(path, callback) {\n        var callbacks = callbackMap[path];\n        if (callbacks) {\n            if (callback) {\n                for (var i = 0, j = callbacks.length; i < j; i++) {\n                    if (callback === callbacks[i]) {\n                        callbacks.splice(i, 1);\n                        break;\n                    }\n                }\n            } else {\n                callbackMap[path] = [];\n            }\n        }\n    };\n\n    // \n    model.$extend = function() {\n        /* jshint -W064 */\n        return ViewModel(Object.create(this));\n        /* jshint +W064 */\n    };\n\n    model.$destroy = function() {\n        for (var path in callbackMap) {\n            if (callbackMap.hasOwnProperty(path)) {\n                var callbacks = callbackMap[path] || emptyArray;\n\n                for (var i = 0, j = callbacks.length; i < j; i++) {\n                    var callback = callbacks[i];\n                    if (typeof callback === 'object' && callback.destroy) {\n                        callback.destroy();\n                    }\n                }\n            }\n        }\n\n        callbackMap = {};\n    };\n\n    observer.on('changed', function(change) {\n        var path = change.path;\n        if (path && path.charAt(0) === '$') {\n            return;\n        }\n\n        var callbacks = callbackMap[path] || emptyArray;\n\n        for (var i = 0, j = callbacks.length; i < j; i++) {\n            var callback = callbacks[i];\n            if (typeof callback === 'object' && callback.update) {\n                callback.update();\n            } else if (typeof callback === 'function') {\n                callback(change);\n            }\n        }\n    });\n\n    return model;\n};\n\nmodule.exports = ViewModel;\n"]}